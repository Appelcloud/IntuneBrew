name: Quality Assurance Testing

on:
  # Run after the update-missing-bundleids workflow completes
  workflow_run:
    workflows: ["Update Missing BundleIDs"]
    types:
      - completed
  # Run on a schedule (daily at 2 AM UTC)
  schedule:
    - cron: "0 2 * * *"
  # Allow manual triggering
  workflow_dispatch:
    inputs:
      specific_app:
        description: "Specific app to test (leave empty to test all apps that need testing)"
        required: false
        default: ""
        type: string
      force_all:
        description: "Force test all apps regardless of version"
        required: false
        default: false
        type: boolean
      max_apps:
        description: "Maximum number of apps to test in one run (default: 50)"
        required: false
        default: "50"
        type: string

jobs:
  get-app-list:
    runs-on: ubuntu-latest
    outputs:
      app_list: ${{ steps.get-apps.outputs.app_list }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Get list of apps
        id: get-apps
        run: |
          # Create a temporary file to store apps that need testing
          touch apps_to_test.txt

          # Check if a specific app was requested
          if [[ -n "${{ github.event.inputs.specific_app }}" ]]; then
            SPECIFIC_APP="${{ github.event.inputs.specific_app }}"
            echo "Testing specific app: $SPECIFIC_APP"
            
            # Verify the app exists
            if [ -f "Apps/${SPECIFIC_APP}.json" ]; then
              echo "$SPECIFIC_APP" > apps_to_test.txt
            else
              echo "::error::Specified app not found: $SPECIFIC_APP"
              exit 1
            fi
          else
            # Process each app to check if it needs testing
            for APP_FILE in Apps/*.json; do
              APP_NAME=$(basename "$APP_FILE" .json)
              
              # Extract current version and previously tested version
              CURRENT_VERSION=$(jq -r '.version' "$APP_FILE")
              PREVIOUS_QA_VERSION=$(jq -r '.qa_info.installed_version // "none"' "$APP_FILE")
              HAS_QA_INFO=$(jq 'has("qa_info")' "$APP_FILE")
              
              # Force testing all apps if requested
              if [[ "${{ github.event.inputs.force_all }}" == "true" ]]; then
                echo "$APP_NAME" >> apps_to_test.txt
                echo "Adding $APP_NAME (force all)"
              # Skip if app has been tested before and version hasn't changed
              elif [[ "$HAS_QA_INFO" == "true" && "$CURRENT_VERSION" == "$PREVIOUS_QA_VERSION" ]]; then
                echo "Skipping $APP_NAME - already tested version $CURRENT_VERSION"
              else
                # App needs testing - either never tested or version changed
                echo "$APP_NAME" >> apps_to_test.txt
                if [[ "$HAS_QA_INFO" == "true" ]]; then
                  echo "Adding $APP_NAME - version changed from $PREVIOUS_QA_VERSION to $CURRENT_VERSION"
                else
                  echo "Adding $APP_NAME - never tested before"
                fi
              fi
            done
          fi

          # Get max number of apps to test
          MAX_APPS="${{ github.event.inputs.max_apps }}"
          if [[ -z "$MAX_APPS" ]]; then
            MAX_APPS=50
          fi

          # Get a subset of apps for testing
          APP_LIST=$(cat apps_to_test.txt | head -n $MAX_APPS | jq -R -s -c 'split("\n") | map(select(length > 0))')
          echo "app_list=$APP_LIST" >> $GITHUB_OUTPUT
          echo "Found $(echo $APP_LIST | jq '. | length') apps to test (max: $MAX_APPS)"

  test-installation:
    needs: get-app-list
    runs-on: macos-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    permissions:
      contents: write # This gives the job permission to write to the repository
    strategy:
      fail-fast: false
      matrix:
        app_name: ${{ fromJson(needs.get-app-list.outputs.app_list) }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.PAT }}

      - name: Set app to test
        id: set-app
        run: |
          echo "APP_NAME=${{ matrix.app_name }}" >> $GITHUB_ENV
          echo "Testing app: ${{ matrix.app_name }}"

      - name: Read app information
        id: app-info
        run: |
          if [ ! -f "Apps/${APP_NAME}.json" ]; then
            echo "::error::App JSON file not found: Apps/${APP_NAME}.json"
            exit 1
          fi

          # Read app details from JSON
          APP_JSON=$(cat "Apps/${APP_NAME}.json")
          APP_DISPLAY_NAME=$(echo "$APP_JSON" | jq -r '.name')
          APP_URL=$(echo "$APP_JSON" | jq -r '.url')
          APP_VERSION=$(echo "$APP_JSON" | jq -r '.version')
          APP_SHA=$(echo "$APP_JSON" | jq -r '.sha')
          APP_BUNDLE_ID=$(echo "$APP_JSON" | jq -r '.bundleId')

          echo "APP_DISPLAY_NAME=$APP_DISPLAY_NAME" >> $GITHUB_ENV
          echo "APP_URL=$APP_URL" >> $GITHUB_ENV
          echo "APP_VERSION=$APP_VERSION" >> $GITHUB_ENV
          echo "APP_SHA=$APP_SHA" >> $GITHUB_ENV
          echo "APP_BUNDLE_ID=$APP_BUNDLE_ID" >> $GITHUB_ENV

          echo "Testing installation for $APP_DISPLAY_NAME version $APP_VERSION"
          echo "URL: $APP_URL"
          echo "Bundle ID: $APP_BUNDLE_ID"

      - name: Download app package
        id: download
        run: |
          echo "📥 Downloading $APP_DISPLAY_NAME from $APP_URL..."
          mkdir -p temp_downloads

          # Extract file extension from URL
          FILE_EXT=$(echo "$APP_URL" | awk -F. '{print tolower($NF)}')

          # Handle URLs that might have query parameters
          if [[ "$FILE_EXT" == *"?"* ]]; then
            FILE_EXT=$(echo "$FILE_EXT" | cut -d'?' -f1)
          fi

          # Set the download filename based on extension
          if [[ "$FILE_EXT" == "pkg" || "$FILE_EXT" == "dmg" || "$FILE_EXT" == "zip" ]]; then
            DOWNLOAD_FILENAME="${APP_NAME}.${FILE_EXT}"
          else
            # Default to .pkg if extension is unknown or not standard
            DOWNLOAD_FILENAME="${APP_NAME}.pkg"
          fi

          echo "File extension detected: $FILE_EXT"
          echo "Download filename: $DOWNLOAD_FILENAME"
          echo "FILE_EXT=$FILE_EXT" >> $GITHUB_ENV
          echo "DOWNLOAD_FILENAME=$DOWNLOAD_FILENAME" >> $GITHUB_ENV

          # Download the file
          curl -L -o "temp_downloads/$DOWNLOAD_FILENAME" "$APP_URL"

          if [ $? -ne 0 ]; then
            echo "::error::Failed to download package from $APP_URL"
            echo "DOWNLOAD_STATUS=failed" >> $GITHUB_ENV
            echo "QA_RESULT=Failed to download package" >> $GITHUB_ENV
            exit 1
          else
            echo "✅ Download successful"
            echo "DOWNLOAD_STATUS=success" >> $GITHUB_ENV
          fi

          # Verify SHA256 checksum if provided
          if [ -n "$APP_SHA" ] && [ "$APP_SHA" != "null" ]; then
            echo "🔐 Verifying SHA256 checksum..."
            DOWNLOADED_SHA=$(shasum -a 256 "temp_downloads/$DOWNLOAD_FILENAME" | awk '{print $1}')
            echo "Expected: $APP_SHA"
            echo "Actual: $DOWNLOADED_SHA"
            
            if [ "$DOWNLOADED_SHA" = "$APP_SHA" ]; then
              echo "✅ SHA256 checksum verified successfully"
              echo "SHA_STATUS=verified" >> $GITHUB_ENV
            else
              echo "❌ SHA256 checksum verification failed"
              echo "SHA_STATUS=failed" >> $GITHUB_ENV
              echo "QA_RESULT=SHA256 checksum verification failed" >> $GITHUB_ENV
              exit 1
            fi
          else
            echo "⚠️ No SHA256 checksum provided for verification"
            echo "SHA_STATUS=not_provided" >> $GITHUB_ENV
          fi

      - name: Install app
        id: install
        if: env.DOWNLOAD_STATUS == 'success'
        run: |
          set -x # Enable command tracing for detailed debugging
          echo "📦 Installing $APP_DISPLAY_NAME..."

          # Create a file to capture installation output
          touch install_output.txt
          INSTALL_STATUS=0

          # Install based on file type
          if [[ "$FILE_EXT" == "pkg" ]]; then
            echo "Installing PKG file..." | tee -a install_output.txt
            sudo installer -pkg "temp_downloads/$DOWNLOAD_FILENAME" -target / >> install_output.txt 2>&1
            INSTALL_STATUS=$?

          elif [[ "$FILE_EXT" == "dmg" ]]; then
            echo "Installing from DMG file..." | tee -a install_output.txt
            
            # Create temporary files for hdiutil output
            HDIUTIL_STDOUT_LOG="hdiutil_stdout.log"
            HDIUTIL_STDERR_LOG="hdiutil_stderr.log"
            touch $HDIUTIL_STDOUT_LOG $HDIUTIL_STDERR_LOG

            echo "Attempting to mount DMG: temp_downloads/$DOWNLOAD_FILENAME with flags -nobrowse -readonly -noverify -noautoopen" | tee -a install_output.txt
            
            # Execute hdiutil attach and capture its exit status, redirecting stdout and stderr to log files
            hdiutil attach "temp_downloads/$DOWNLOAD_FILENAME" -nobrowse -readonly -noverify -noautoopen > "$HDIUTIL_STDOUT_LOG" 2> "$HDIUTIL_STDERR_LOG"
            ATTACH_CMD_STATUS=$?

            echo "--- hdiutil attach STDOUT ---" | tee -a install_output.txt
            cat "$HDIUTIL_STDOUT_LOG" | tee -a install_output.txt
            echo "--- End hdiutil attach STDOUT ---" | tee -a install_output.txt

            echo "--- hdiutil attach STDERR ---" | tee -a install_output.txt
            cat "$HDIUTIL_STDERR_LOG" | tee -a install_output.txt
            echo "--- End hdiutil attach STDERR ---" | tee -a install_output.txt
            
            echo "hdiutil attach command finished with status: $ATTACH_CMD_STATUS" | tee -a install_output.txt

            MOUNT_POINT="" # Initialize MOUNT_POINT

            if [ $ATTACH_CMD_STATUS -eq 0 ]; then
              # Parse mount point more robustly from successful STDOUT
              MOUNT_POINT=$(cat "$HDIUTIL_STDOUT_LOG" | grep -oE '/Volumes/.*' | tail -n 1)
              if [ -z "$MOUNT_POINT" ]; then
                echo "DMG attach command succeeded (status 0), but could not parse mount point from STDOUT. MOUNT_POINT remains empty." | tee -a install_output.txt
              else
                # Further check if the parsed MOUNT_POINT actually exists as a directory
                if [ -d "$MOUNT_POINT" ]; then
                  echo "DMG successfully mounted at: $MOUNT_POINT" | tee -a install_output.txt
                else
                  echo "DMG attach command succeeded and mount point '$MOUNT_POINT' was parsed from STDOUT, but it is not a valid directory." | tee -a install_output.txt
                  MOUNT_POINT="" # Invalidate mount point if it's not a directory
                fi
              fi
            else
              echo "DMG attach command failed with status $ATTACH_CMD_STATUS. MOUNT_POINT will be empty." | tee -a install_output.txt
              # MOUNT_POINT remains empty as initialized
            fi
            
            # Clean up temporary hdiutil log files
            rm -f "$HDIUTIL_STDOUT_LOG" "$HDIUTIL_STDERR_LOG"

            # List DMG contents for debugging, only if MOUNT_POINT is valid
            echo "Listing DMG contents (if mount was successful and path is valid):" | tee -a install_output.txt
            if [ -n "$MOUNT_POINT" ]; then # MOUNT_POINT should be non-empty and a directory (checked above)
                ls -la "$MOUNT_POINT" | tee -a install_output.txt
            else
                echo "Mount point is not set or invalid. Cannot list DMG contents." | tee -a install_output.txt
            fi
            
            # Try multiple approaches to find the app
            
            # 1. First check for .app files directly in the mount point
            APP_IN_DMG=$(find "$MOUNT_POINT" -maxdepth 1 -name "*.app" | head -n 1)
            
            # 2. If not found, search deeper with increased depth
            if [ -z "$APP_IN_DMG" ]; then
              APP_IN_DMG=$(find "$MOUNT_POINT" -maxdepth 5 -name "*.app" | head -n 1)
            fi
            
            # 3. If still not found, try to find by app name
            if [ -z "$APP_IN_DMG" ]; then
              APP_IN_DMG=$(find "$MOUNT_POINT" -maxdepth 5 -name "*$APP_DISPLAY_NAME*.app" -o -name "*$APP_NAME*.app" | head -n 1)
            fi
            
            if [ -n "$APP_IN_DMG" ]; then
              echo "Found app: $(basename "$APP_IN_DMG")" | tee -a install_output.txt
              sudo cp -R "$APP_IN_DMG" "/Applications/" >> install_output.txt 2>&1
              INSTALL_STATUS=$?
            else
              # Check for pkg files in the DMG
              PKG_IN_DMG=$(find "$MOUNT_POINT" -maxdepth 5 -name "*.pkg" | head -n 1)
              if [ -n "$PKG_IN_DMG" ]; then
                echo "Found pkg inside DMG: $(basename "$PKG_IN_DMG")" | tee -a install_output.txt
                sudo installer -pkg "$PKG_IN_DMG" -target / >> install_output.txt 2>&1
                INSTALL_STATUS=$?
              else
                # Try to find any installer or app that might be there
                INSTALLER_IN_DMG=$(find "$MOUNT_POINT" -maxdepth 5 -name "*install*" -o -name "*setup*" | grep -v -i "readme\|manual\|guide" | head -n 1)
                if [ -n "$INSTALLER_IN_DMG" ]; then
                  echo "Found potential installer: $(basename "$INSTALLER_IN_DMG")" | tee -a install_output.txt
                  if [[ "$INSTALLER_IN_DMG" == *.app ]]; then
                    # It's an installer app, copy it and run it
                    TMP_INSTALLER="/tmp/$(basename "$INSTALLER_IN_DMG")"
                    sudo cp -R "$INSTALLER_IN_DMG" "$TMP_INSTALLER" >> install_output.txt 2>&1
                    open "$TMP_INSTALLER" >> install_output.txt 2>&1
                    # Give it some time to run
                    sleep 30
                    INSTALL_STATUS=0
                  else
                    echo "Found installer but don't know how to run it" | tee -a install_output.txt
                    INSTALL_STATUS=1
                  fi
                else
                  echo "No installable content found in DMG" | tee -a install_output.txt
                  INSTALL_STATUS=1
                fi
              fi
            fi
            # Unmount the DMG
            hdiutil detach "$MOUNT_POINT" -quiet || hdiutil detach "$MOUNT_POINT" -force -quiet

          elif [[ "$FILE_EXT" == "zip" ]]; then
            echo "Installing from ZIP file..." | tee -a install_output.txt
            # Create a temporary directory for extraction
            mkdir -p temp_extract
            
            # Extract the ZIP file
            unzip -q "temp_downloads/$DOWNLOAD_FILENAME" -d temp_extract >> install_output.txt 2>&1
            
            # Find .app files in the extracted content
            APP_IN_ZIP=$(find "temp_extract" -name "*.app" -maxdepth 2 | head -n 1)
            
            if [ -n "$APP_IN_ZIP" ]; then
              echo "Found app: $(basename "$APP_IN_ZIP")" | tee -a install_output.txt
              sudo cp -R "$APP_IN_ZIP" "/Applications/" >> install_output.txt 2>&1
              INSTALL_STATUS=$?
            else
              echo "No .app file found in ZIP" | tee -a install_output.txt
              INSTALL_STATUS=1
            fi
            
            # Clean up
            rm -rf temp_extract

          else
            echo "Unsupported file type: $FILE_EXT" | tee -a install_output.txt
            INSTALL_STATUS=1
          fi

          # Check installation status
          if [ $INSTALL_STATUS -ne 0 ]; then
            echo "❌ Installation failed"
            echo "Installation output:"
            cat install_output.txt
            echo "INSTALL_STATUS=failed" >> $GITHUB_ENV
            echo "QA_RESULT=Installation failed: $(head -n 1 install_output.txt)" >> $GITHUB_ENV
            exit 1
          else
            echo "✅ Installation successful"
            echo "INSTALL_STATUS=success" >> $GITHUB_ENV
          fi

      - name: Verify installation
        id: verify
        if: env.INSTALL_STATUS == 'success'
        run: |
          echo "🔍 Verifying installation..."

          # Check if app exists in Applications folder
          APP_PATH=$(find /Applications -maxdepth 1 -name "*.app" | grep -i "$APP_DISPLAY_NAME" || echo "")

          if [ -z "$APP_PATH" ]; then
            echo "❌ App not found in Applications folder"
            echo "Available apps:"
            ls -la /Applications
            echo "VERIFY_STATUS=app_not_found" >> $GITHUB_ENV
            echo "QA_RESULT=App not found in Applications folder after installation" >> $GITHUB_ENV
          else
            echo "✅ App found at: $APP_PATH"
            echo "VERIFY_STATUS=app_found" >> $GITHUB_ENV
            
            # Verify bundle ID if provided
            if [ -n "$APP_BUNDLE_ID" ] && [ "$APP_BUNDLE_ID" != "null" ]; then
              echo "🔍 Verifying bundle ID..."
              
              # Method 1: Using mdls
              ACTUAL_BUNDLE_ID=$(mdls -name kMDItemCFBundleIdentifier -raw "$APP_PATH" 2>/dev/null || echo "Not found")
              
              # Method 2: Using PlistBuddy if mdls failed
              if [ "$ACTUAL_BUNDLE_ID" = "Not found" ] || [ "$ACTUAL_BUNDLE_ID" = "(null)" ]; then
                if [ -f "$APP_PATH/Contents/Info.plist" ]; then
                  ACTUAL_BUNDLE_ID=$(/usr/libexec/PlistBuddy -c "Print :CFBundleIdentifier" "$APP_PATH/Contents/Info.plist" 2>/dev/null || echo "Not found")
                fi
              fi
              
              echo "Expected bundle ID: $APP_BUNDLE_ID"
              echo "Actual bundle ID: $ACTUAL_BUNDLE_ID"
              
              if [ "$ACTUAL_BUNDLE_ID" = "$APP_BUNDLE_ID" ]; then
                echo "✅ Bundle ID verified successfully"
                echo "BUNDLE_ID_STATUS=verified" >> $GITHUB_ENV
                echo "QA_RESULT=Installation successful and verified" >> $GITHUB_ENV
              else
                echo "❌ Bundle ID verification failed"
                echo "BUNDLE_ID_STATUS=mismatch" >> $GITHUB_ENV
                echo "QA_RESULT=Bundle ID mismatch: expected $APP_BUNDLE_ID, got $ACTUAL_BUNDLE_ID" >> $GITHUB_ENV
              fi
            else
              echo "⚠️ No bundle ID provided for verification"
              echo "BUNDLE_ID_STATUS=not_provided" >> $GITHUB_ENV
              echo "QA_RESULT=Installation successful but bundle ID not verified" >> $GITHUB_ENV
            fi
            
            # Try to get app version
            APP_VERSION_INSTALLED="Unknown"
            if [ -f "$APP_PATH/Contents/Info.plist" ]; then
              APP_VERSION_INSTALLED=$(/usr/libexec/PlistBuddy -c "Print :CFBundleShortVersionString" "$APP_PATH/Contents/Info.plist" 2>/dev/null || echo "Unknown")
              echo "Installed version: $APP_VERSION_INSTALLED"
              echo "APP_VERSION_INSTALLED=$APP_VERSION_INSTALLED" >> $GITHUB_ENV
            fi
          fi

      - name: Update JSON with QA results
        if: always()
        run: |
          echo "📝 Updating JSON file with QA results..."

          # Set default QA result if not already set
          if [ -z "$QA_RESULT" ]; then
            if [ "$VERIFY_STATUS" = "app_found" ] && [ "$BUNDLE_ID_STATUS" = "verified" ]; then
              QA_RESULT="Installation successful and verified"
            elif [ "$VERIFY_STATUS" = "app_found" ]; then
              QA_RESULT="Installation successful but bundle ID verification ${BUNDLE_ID_STATUS}"
            elif [ "$INSTALL_STATUS" = "success" ]; then
              QA_RESULT="Installation reported success but app not found"
            elif [ "$DOWNLOAD_STATUS" = "success" ]; then
              QA_RESULT="Download successful but installation failed"
            else
              QA_RESULT="Download failed"
            fi
          fi

          # Create a timestamp
          QA_TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

          # Update the JSON file with the QA information
          jq --arg timestamp "$QA_TIMESTAMP" \
             --arg result "$QA_RESULT" \
             --arg download "${DOWNLOAD_STATUS:-unknown}" \
             --arg sha "${SHA_STATUS:-unknown}" \
             --arg install "${INSTALL_STATUS:-unknown}" \
             --arg verify "${VERIFY_STATUS:-unknown}" \
             --arg bundle "${BUNDLE_ID_STATUS:-unknown}" \
             --arg version "${APP_VERSION_INSTALLED:-unknown}" \
             '.qa_info = {
                "qa_timestamp": $timestamp,
                "qa_result": $result,
                "download_status": $download,
                "sha_status": $sha,
                "install_status": $install,
                "verify_status": $verify,
                "bundle_id_status": $bundle,
                "installed_version": $version
              }' "Apps/${APP_NAME}.json" > "Apps/${APP_NAME}.json.tmp"

          mv "Apps/${APP_NAME}.json.tmp" "Apps/${APP_NAME}.json"

          echo "✅ Updated JSON file with QA results"
          echo "QA Result: $QA_RESULT"

      # We don't commit changes in individual test jobs to avoid conflicts
      # Instead, we'll collect all results and commit them in a separate job

      - name: Output summary
        if: always()
        run: |
          # Create a summary for GitHub Actions
          echo "## Quality Assurance Results for $APP_DISPLAY_NAME" >> $GITHUB_STEP_SUMMARY
          echo "| Metric | Value |" >> $GITHUB_STEP_SUMMARY
          echo "| --- | --- |" >> $GITHUB_STEP_SUMMARY
          echo "| App Name | $APP_DISPLAY_NAME |" >> $GITHUB_STEP_SUMMARY
          echo "| Version | $APP_VERSION |" >> $GITHUB_STEP_SUMMARY
          echo "| Download Status | ${DOWNLOAD_STATUS:-Unknown} |" >> $GITHUB_STEP_SUMMARY
          echo "| SHA Verification | ${SHA_STATUS:-N/A} |" >> $GITHUB_STEP_SUMMARY
          echo "| Installation Status | ${INSTALL_STATUS:-Unknown} |" >> $GITHUB_STEP_SUMMARY
          echo "| App Verification | ${VERIFY_STATUS:-Unknown} |" >> $GITHUB_STEP_SUMMARY
          echo "| Bundle ID Verification | ${BUNDLE_ID_STATUS:-Unknown} |" >> $GITHUB_STEP_SUMMARY
          echo "| Installed Version | ${APP_VERSION_INSTALLED:-Unknown} |" >> $GITHUB_STEP_SUMMARY
          echo "| QA Result | $QA_RESULT |" >> $GITHUB_STEP_SUMMARY

          # Add installation output if available
          if [ -f "install_output.txt" ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### Installation Output" >> $GITHUB_STEP_SUMMARY
            echo "```" >> $GITHUB_STEP_SUMMARY
            cat install_output.txt >> $GITHUB_STEP_SUMMARY
            echo "```" >> $GITHUB_STEP_SUMMARY
          fi

  # New job to commit all changes at once after all tests are complete
  commit-changes:
    needs: test-installation
    runs-on: ubuntu-latest
    if: always()
    permissions:
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.PAT }}

      - name: Commit and push all changes
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

          # Check if there are any changes to commit
          if git status --porcelain | grep -q "Apps/"; then
            echo "Changes detected, committing..."
            git add Apps/*.json
            git commit -m "Add QA results from automated testing ($(date +'%Y-%m-%d'))"
            
            # Push using the PAT for authentication
            echo "Pushing changes to repository..."
            git push
            
            if [ $? -eq 0 ]; then
              echo "✅ Successfully pushed changes to repository"
            else
              echo "❌ Failed to push changes to repository"
            fi
          else
            echo "No changes to commit"
          fi
