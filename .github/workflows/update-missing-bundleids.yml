name: Update Missing BundleIDs

on:
  workflow_dispatch:
  schedule:
    - cron: "0 0 * * 0" # Run weekly at midnight on Sunday

jobs:
  update-bundleids:
    runs-on: macos-latest
    permissions:
      contents: write # This gives the job permission to write to the repository

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.PAT }}

      - name: Find apps with missing bundleIds
        id: find-apps
        run: |
          echo "Finding apps with missing bundleIds..."

          # Create an array to store apps with missing bundleIds
          APPS_TO_PROCESS=()

          # Loop through all JSON files in the Apps directory
          for APP_JSON_PATH in Apps/*.json; do
            # Extract app name from filename
            APP_NAME=$(basename "$APP_JSON_PATH" .json)
            
            # Check if bundleId is null or empty
            BUNDLE_ID=$(jq -r '.bundleId' "$APP_JSON_PATH")
            if [ "$BUNDLE_ID" = "null" ] || [ -z "$BUNDLE_ID" ]; then
              echo "Found app with missing bundleId: $APP_NAME"
              APPS_TO_PROCESS+=("$APP_JSON_PATH")
            fi
          done

          # Save the list of apps to process
          echo "APPS_COUNT=${#APPS_TO_PROCESS[@]}" >> $GITHUB_ENV

          if [ ${#APPS_TO_PROCESS[@]} -eq 0 ]; then
            echo "No apps with missing bundleIds found."
            echo "APPS_TO_PROCESS=" >> $GITHUB_ENV
          else
            # Convert array to newline-separated string and save to a file
            printf "%s\n" "${APPS_TO_PROCESS[@]}" > /tmp/apps_to_process.txt
            echo "Found ${#APPS_TO_PROCESS[@]} apps with missing bundleIds."
          fi

      - name: Process apps with missing bundleIds
        if: env.APPS_COUNT != '0'
        run: |
          echo "Processing ${APPS_COUNT} apps with missing bundleIds..."

          # Initialize a flag to track if any changes were made
          echo "CHANGES_MADE=false" >> $GITHUB_ENV

          # Process each app from the file
          while IFS= read -r APP_JSON_PATH || [ -n "$APP_JSON_PATH" ]; do
            echo "==============================================="
            echo "Processing $APP_JSON_PATH"
            
            # Read app details from JSON
            APP_JSON=$(cat "$APP_JSON_PATH")
            APP_NAME=$(echo "$APP_JSON" | jq -r '.name')
            APP_URL=$(echo "$APP_JSON" | jq -r '.url')
            APP_VERSION=$(echo "$APP_JSON" | jq -r '.version')
            APP_SHA=$(echo "$APP_JSON" | jq -r '.sha')
            
            echo "App Name: $APP_NAME"
            echo "Version: $APP_VERSION"
            echo "URL: $APP_URL"
            
            # Create a temporary directory for this app
            TEMP_DIR="temp_${APP_NAME// /_}"
            mkdir -p "$TEMP_DIR"
            cd "$TEMP_DIR"
            
            # Download with generic name first
            DOWNLOAD_PATH="downloaded_file"
            echo "üì• Downloading $APP_NAME from $APP_URL..."
            curl -L -o "$DOWNLOAD_PATH" "$APP_URL"
            
            if [ $? -ne 0 ]; then
              echo "‚ùå Failed to download file"
              cd ..
              rm -rf "$TEMP_DIR"
              continue
            fi
            
            # Determine file type based on content
            echo "üîç Detecting file type..."
            FILE_TYPE="unknown"
            
            # Check file signature/magic bytes
            FILE_INFO=$(file "$DOWNLOAD_PATH")
            echo "File info: $FILE_INFO"
            
            if [[ "$FILE_INFO" == *"Zip archive"* ]]; then
              FILE_TYPE="zip"
              mv "$DOWNLOAD_PATH" "app_package.zip"
              DOWNLOAD_PATH="app_package.zip"
              echo "Detected ZIP file"
            elif [[ "$FILE_INFO" == *"xar archive"* ]] || [[ "$FILE_INFO" == *"installer"* ]] || [[ "$FILE_INFO" == *"package"* ]]; then
              FILE_TYPE="pkg"
              mv "$DOWNLOAD_PATH" "app_package.pkg"
              DOWNLOAD_PATH="app_package.pkg"
              echo "Detected PKG file"
            elif [[ "$FILE_INFO" == *"disk image"* ]] || [[ "$FILE_INFO" == *"DMG"* ]]; then
              FILE_TYPE="dmg"
              mv "$DOWNLOAD_PATH" "app_package.dmg"
              DOWNLOAD_PATH="app_package.dmg"
              echo "Detected DMG file"
            else
              # Fallback to URL-based detection if content detection fails
              if [[ "$APP_URL" == *".dmg" ]]; then
                FILE_TYPE="dmg"
                mv "$DOWNLOAD_PATH" "app_package.dmg"
                DOWNLOAD_PATH="app_package.dmg"
              elif [[ "$APP_URL" == *".zip" ]]; then
                FILE_TYPE="zip"
                mv "$DOWNLOAD_PATH" "app_package.zip"
                DOWNLOAD_PATH="app_package.zip"
              elif [[ "$APP_URL" == *".pkg" ]]; then
                FILE_TYPE="pkg"
                mv "$DOWNLOAD_PATH" "app_package.pkg"
                DOWNLOAD_PATH="app_package.pkg"
              else
                # Default to pkg if we can't determine
                FILE_TYPE="pkg"
                mv "$DOWNLOAD_PATH" "app_package.pkg"
                DOWNLOAD_PATH="app_package.pkg"
              fi
              echo "Using URL-based detection: $FILE_TYPE"
            fi
            
            echo "File type determined: $FILE_TYPE"
            
            # Verify SHA256 checksum if provided
            if [ -n "$APP_SHA" ] && [ "$APP_SHA" != "null" ]; then
              echo "üîê Verifying SHA256 checksum..."
              DOWNLOADED_SHA=$(shasum -a 256 "$DOWNLOAD_PATH" | awk '{print $1}')
              echo "Expected: $APP_SHA"
              echo "Actual: $DOWNLOADED_SHA"
              
              if [ "$DOWNLOADED_SHA" = "$APP_SHA" ]; then
                echo "‚úÖ SHA256 checksum verified successfully"
              else
                echo "‚ùå SHA256 checksum verification failed"
                continue
              fi
            fi
            
            # Install the app based on file type
            if [ "$FILE_TYPE" = "pkg" ]; then
              # Install PKG file
              echo "üì¶ Installing $APP_NAME from PKG..."
              sudo installer -pkg app_package.pkg -target /
              
              if [ $? -ne 0 ]; then
                echo "‚ùå Installation failed"
                continue
              fi
              
              echo "‚úÖ Installation successful"
            fi
            
            if [ "$FILE_TYPE" = "dmg" ]; then
              # Mount DMG file
              echo "üíø Mounting DMG file..."
              MOUNT_POINT="/Volumes/AppDMG"
              hdiutil attach -mountpoint "$MOUNT_POINT" app_package.dmg -nobrowse
              
              if [ $? -ne 0 ]; then
                echo "‚ùå Failed to mount DMG file"
                continue
              fi
              
              # Find the .app file in the mounted DMG
              echo "üîç Finding .app in DMG..."
              DMG_APP=$(find "$MOUNT_POINT" -maxdepth 1 -name "*.app" | head -1)
              
              if [ -z "$DMG_APP" ]; then
                echo "‚ùå Could not find .app file in DMG"
                hdiutil detach "$MOUNT_POINT" -force
                continue
              fi
              
              echo "üìÇ Found app: $DMG_APP"
              
              # Copy the app to Applications folder
              echo "üìã Copying app to Applications folder..."
              cp -R "$DMG_APP" /Applications/
              
              if [ $? -ne 0 ]; then
                echo "‚ùå Failed to copy app to Applications folder"
                hdiutil detach "$MOUNT_POINT" -force
                continue
              fi
              
              echo "‚úÖ App copied successfully"
              
              # Unmount the DMG
              echo "üíø Unmounting DMG..."
              hdiutil detach "$MOUNT_POINT" -force
            fi
            
            if [ "$FILE_TYPE" = "zip" ]; then
              # Extract ZIP file
              echo "üì¶ Extracting ZIP file..."
              EXTRACT_DIR="app_extracted"
              mkdir -p "$EXTRACT_DIR"
              unzip -q app_package.zip -d "$EXTRACT_DIR"
              
              if [ $? -ne 0 ]; then
                echo "‚ùå Failed to extract ZIP file"
                continue
              fi
              
              # Find the .app file in the extracted contents
              echo "üîç Finding .app in extracted contents..."
              ZIP_APP=$(find "$EXTRACT_DIR" -name "*.app" -type d | head -1)
              
              if [ -z "$ZIP_APP" ]; then
                echo "‚ùå Could not find .app file in ZIP contents"
                rm -rf "$EXTRACT_DIR"
                continue
              fi
              
              echo "üìÇ Found app: $ZIP_APP"
              
              # Copy the app to Applications folder
              echo "üìã Copying app to Applications folder..."
              cp -R "$ZIP_APP" /Applications/
              
              if [ $? -ne 0 ]; then
                echo "‚ùå Failed to copy app to Applications folder"
                rm -rf "$EXTRACT_DIR"
                continue
              fi
              
              echo "‚úÖ App copied successfully"
              
              # Clean up extracted files
              echo "üßπ Cleaning up extracted files..."
              rm -rf "$EXTRACT_DIR"
            fi
            
            # Find the app in Applications folder
            echo "üîç Finding app in Applications folder..."
            
            # Try different search strategies to find the app
            # Strategy 1: Direct match with app name
            APP_PATH=$(find /Applications -maxdepth 1 -name "*.app" | grep -i "$APP_NAME" || echo "")
            
            # Strategy 2: If not found, try with parts of the name (for apps with spaces)
            if [ -z "$APP_PATH" ]; then
              echo "Direct match not found, trying with parts of the name..."
              # Split app name by spaces and search for each part
              for WORD in $APP_NAME; do
                if [ ${#WORD} -gt 3 ]; then  # Only use words longer than 3 characters
                  POTENTIAL_APP=$(find /Applications -maxdepth 1 -name "*.app" | grep -i "$WORD" | head -1)
                  if [ -n "$POTENTIAL_APP" ]; then
                    APP_PATH="$POTENTIAL_APP"
                    echo "Found app using partial match: $WORD"
                    break
                  fi
                fi
              done
            fi
            
            # Strategy 3: List all apps and try to find the closest match
            if [ -z "$APP_PATH" ]; then
              echo "Partial match not found, trying to find the closest match..."
              # List all apps and save to a file
              find /Applications -maxdepth 1 -name "*.app" > /tmp/all_apps.txt
              echo "Available apps in Applications folder:"
              cat /tmp/all_apps.txt
              
              # Try to find a match based on the JSON filename
              APP_FILENAME=$(basename "$APP_JSON_PATH" .json)
              APP_PATH=$(grep -i "$APP_FILENAME" /tmp/all_apps.txt | head -1)
              
              if [ -n "$APP_PATH" ]; then
                echo "Found app using filename match: $APP_FILENAME"
              fi
            fi
            
            if [ -z "$APP_PATH" ]; then
              echo "‚ùå Could not find app in Applications folder"
              echo "Available apps:"
              ls -la /Applications
              continue
            fi
            
            echo "üìÇ App path: $APP_PATH"
            
            # Print app details for debugging
            echo "üìã App details:"
            ls -la "$APP_PATH"
            echo "App bundle contents:"
            ls -la "$APP_PATH/Contents" || echo "Could not access Contents directory"
            
            # Get app bundle ID using multiple methods
            echo "üîç Extracting bundleId..."
            
            # Method 1: Using mdls
            echo "Trying mdls method..."
            ACTUAL_BUNDLE_ID=$(mdls -name kMDItemCFBundleIdentifier -raw "$APP_PATH" 2>/dev/null || echo "Not found")
            echo "mdls result: $ACTUAL_BUNDLE_ID"
            
            # Method 2: Using PlistBuddy
            if [ "$ACTUAL_BUNDLE_ID" = "Not found" ] || [ "$ACTUAL_BUNDLE_ID" = "(null)" ]; then
              echo "Trying PlistBuddy method..."
              if [ -f "$APP_PATH/Contents/Info.plist" ]; then
                ACTUAL_BUNDLE_ID=$(/usr/libexec/PlistBuddy -c "Print :CFBundleIdentifier" "$APP_PATH/Contents/Info.plist" 2>/dev/null || echo "Not found")
                echo "PlistBuddy result: $ACTUAL_BUNDLE_ID"
              else
                echo "Info.plist not found at expected location"
              fi
            fi
            
            # Method 3: Using defaults command
            if [ "$ACTUAL_BUNDLE_ID" = "Not found" ] || [ "$ACTUAL_BUNDLE_ID" = "(null)" ]; then
              echo "Trying defaults command method..."
              if [ -f "$APP_PATH/Contents/Info.plist" ]; then
                ACTUAL_BUNDLE_ID=$(defaults read "$APP_PATH/Contents/Info" CFBundleIdentifier 2>/dev/null || echo "Not found")
                echo "defaults command result: $ACTUAL_BUNDLE_ID"
              fi
            fi
            
            # Method 4: Using grep on the Info.plist file
            if [ "$ACTUAL_BUNDLE_ID" = "Not found" ] || [ "$ACTUAL_BUNDLE_ID" = "(null)" ]; then
              echo "Trying grep method..."
              if [ -f "$APP_PATH/Contents/Info.plist" ]; then
                # Extract the line with CFBundleIdentifier and the value after it
                BUNDLE_ID_LINE=$(grep -A1 "CFBundleIdentifier" "$APP_PATH/Contents/Info.plist" | grep -v "CFBundleIdentifier" | grep -o ">.*<" | sed 's/>//;s/<//g')
                if [ -n "$BUNDLE_ID_LINE" ]; then
                  ACTUAL_BUNDLE_ID="$BUNDLE_ID_LINE"
                  echo "grep method result: $ACTUAL_BUNDLE_ID"
                fi
              fi
            fi
            
            echo "üÜî Extracted Bundle ID: $ACTUAL_BUNDLE_ID"
            
            # Update the JSON file if a valid bundleId was found
            if [ "$ACTUAL_BUNDLE_ID" != "Not found" ] && [ "$ACTUAL_BUNDLE_ID" != "(null)" ]; then
              echo "üîÑ Updating bundleId in JSON file..."
              
              # Get absolute path to the JSON file
              ABSOLUTE_JSON_PATH="$GITHUB_WORKSPACE/$APP_JSON_PATH"
              echo "JSON file path: $ABSOLUTE_JSON_PATH"
              
              # Verify the JSON file exists
              if [ ! -f "$ABSOLUTE_JSON_PATH" ]; then
                echo "‚ùå JSON file not found at $ABSOLUTE_JSON_PATH"
                echo "Current directory: $(pwd)"
                echo "Listing workspace directory:"
                ls -la "$GITHUB_WORKSPACE"
                echo "Listing Apps directory:"
                ls -la "$GITHUB_WORKSPACE/Apps" || echo "Apps directory not found"
                continue
              fi
              
              # Create a backup of the original file
              cp "$ABSOLUTE_JSON_PATH" "${ABSOLUTE_JSON_PATH}.bak"
              
              # Update the bundleId in the JSON file using jq
              jq --arg new_bundle_id "$ACTUAL_BUNDLE_ID" '.bundleId = $new_bundle_id' "$ABSOLUTE_JSON_PATH" > "${ABSOLUTE_JSON_PATH}.tmp"
              mv "${ABSOLUTE_JSON_PATH}.tmp" "$ABSOLUTE_JSON_PATH"
              
              echo "‚úÖ Updated bundleId in $ABSOLUTE_JSON_PATH to '$ACTUAL_BUNDLE_ID'"
              echo "CHANGES_MADE=true" >> $GITHUB_ENV
            else
              echo "‚ö†Ô∏è Could not extract a valid bundleId"
            fi
            
            # Clean up the temporary directory
            cd "$GITHUB_WORKSPACE"
            rm -rf "$TEMP_DIR"
            
            echo "==============================================="
          done < /tmp/apps_to_process.txt

      - name: Commit and push changes
        if: env.CHANGES_MADE == 'true'
        run: |
          echo "üìù Committing bundleId changes to repository..."
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

          # Check if there are changes to commit
          if git diff --quiet -- "Apps/"; then
            echo "No changes to commit"
          else
            echo "Changes detected, committing..."
            git add "Apps/"
            git commit -m "Update missing bundleIds for apps"
            
            # Push using the PAT for authentication
            echo "Pushing changes to repository..."
            git push https://${{ secrets.PAT }}@github.com/${{ github.repository }}.git
            
            if [ $? -eq 0 ]; then
              echo "‚úÖ Successfully pushed changes to repository"
            else
              echo "‚ùå Failed to push changes to repository"
              echo "Trying alternative push method..."
              git push
            fi
          fi

      - name: Output summary
        run: |
          # Create a summary for GitHub Actions
          echo "## BundleID Update Results" >> $GITHUB_STEP_SUMMARY
          echo "| Metric | Value |" >> $GITHUB_STEP_SUMMARY
          echo "| --- | --- |" >> $GITHUB_STEP_SUMMARY
          echo "| Apps Processed | $APPS_COUNT |" >> $GITHUB_STEP_SUMMARY
          echo "| Changes Made | $CHANGES_MADE |" >> $GITHUB_STEP_SUMMARY

          if [ "$CHANGES_MADE" = "true" ]; then
            echo "The following apps had their bundleIds updated:" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            # List all modified JSON files
            git diff --name-only -- "Apps/" | while read -r file; do
              app_name=$(basename "$file" .json)
              bundle_id=$(jq -r '.bundleId' "$file")
              echo "- $app_name: $bundle_id" >> $GITHUB_STEP_SUMMARY
            done
          fi
